%
% NOTE -- ONLY EDIT Rgraphviz.Rnw!!!
% Biobase.tex file will get overwritten.
%
%\VignetteIndexEntry{HOWTO Rendering}
%\VignetteDepends{Rgraphviz, graph, Biobase}
%\VignetteKeywords{tools, graphs}
%\VignettePackage{Rgraphviz}

\documentclass{article}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Robject}[1]{{\textit{#1}}}

\author{Jeff Gentry}
\begin{document}
\title{HowTo Render A Graph Using Rgraphviz}
\maketitle

\section{Overview}
This article will demonstrate how to easily render a graph from R into
various formats using the \Rpackage{Rgraphviz}.  To do this,
first we need to generate a R graph using the \Rpackage{graph} package:

<<createGraph>>=
library(Rgraphviz)
set.seed(123)
V <- letters[1:10]
M <- 1:4
g1 <- randomGraph(V, M, .2)
g1
@

\section{Plotting in R Using Different Layout Methods}

It is quite simple to generate a R plot window to display your graph.
Once you have your graph object, simply use the \Rfunction{plot}
method:

<<plotDot, fig=TRUE, echo=FALSE>>=
    z <- plot(g1)
@

The \Rpackage{Rgraphviz} package allows you to specify varying layout
engines, such as "dot" (the default), "neato", and "twopi".  This can
be done using the call to \Rfunction{plot}:

<<plotNeato, fig=TRUE>>=
z <- plot(g1, "neato")
@

The "twopi" layout method requires a graph to be fully connected.
To determine if your graph is fully connected:

<<connected>>=
isConnected(g1)
@

A working "twopi" layout can be seen with this graph:
<<workingTwopi, fig=TRUE>>=
set.seed(123)
V <- letters[14:22]
g2 <- randomEGraph(V, .2)
isConnected(g2)
z <- plot(g2,"twopi")
@

And finally, to demonstrate how the differing layout methods work on
this second graph:
<<g2dot, fig=TRUE>>=
z <- plot(g2,"dot")
@
<<g2neato, fig=TRUE>>=
z <- plot(g2,"neato")
@

Note that there is an option, \Robject{recipEdges} that details how to
deal with reciprocated edges in a graph.  The two options are
\Robject{combined} (the default) and \Robject{distinct}.  This is
mostly useful in directed graphs that have reciprocating edges - the
\Robject{combined} option will display them as a single edge with an
arrow on both ends while \Robject{distinct} shows them as two separate edges.

<<recipEdgesComb, fig=TRUE>>=
rEG <- new("graphNEL", nodes=c("A", "B"), edgemode="directed")
rEG <- addEdge("A", "B", rEG, 1)
rEG <- addEdge("B", "A", rEG, 1)

plot(rEG)
@

In this first example above, the edges were combined, whereas below
they are showed separately.

<<recipEdgesSep, fig=TRUE>>=
plot(rEG, recipEdges="distinct")
@

\section{SubGraphs}

Rgraphviz supports the ability to define specific clustering of
nodes.  This will instruct the layout algorithm to attempt to keep the
clustered nodes close together.  To do this, one must first generate
the desired set (one or more) of subgraphs with the \Robject{graph}
object.

<<getSubgraphs>>=
sg1 <- subGraph(c("a","d","j","i"), g1)
sg1
sg2 <- subGraph(c("b","e","h"), g1)
sg2
sg3 <- subGraph(c("c","f","g"), g1)
sg3
@

To plot using the subgraphs, one must use the \Rfunction{subGList}
argument which accepts a list of every subgraph.

<<subGplot, fig=TRUE>>=
plot(g1, subGList=list(sg1, sg2, sg3))
@

To demonstrate the differences that will appear with different
subgraph patterns, another example is provided:

<<subGPlot2, fig=TRUE>>=
sg1 <- subGraph(c("a","c","d","e","j"), g1)
sg2 <- subGraph(c("f","h","i"), g1)
plot(g1, subGList=list(sg1, sg2))
@

\section{Attributes}

\section{The Attributes List}

There are many visualization options in Graphviz that can be set beyond those
which are given explicit options using Rgraphviz - such as colors of
nodes and edges, which node to center on for twopi plots, node labels,
edge labels, edge weights, arrow heads and tails, etc.  A list of all
available attributes is accessible online at:
http://www.research.att.com/~erg/graphviz/info/attrs.html".  (Note
that there are some differences between default values and also some
attributes will not have an effect in Rgraphviz.  Please see the man
page for \Rfunction{graphvizAttributes} for more details)

Attributes can be set both globally (for the entire graph, for all
edges, all nodes, etc) as well as on a per-node and per-edge basis.
Global attributes are set via a list and passed in as the
\Robject{attrs} argument to \Rfunction{plot}.  A default set of global
attributes are used if nothing else is provided, using the function
\Rfunction{getDefaultAttrs} - users are encouraged to work off of the
return of this function instead of creating their own from scratch as
then attributes which they don't want to change from the defaults will
still be kept intact.  The \Rfunction{getDefaultAttrs} function takes
as a parameter the layout type to be used (dot, neato or twopi) but
defaults to dot.  The \Robject{attrs} list is a four element list
with element names of 'graph', 'cluster', 'edge' and 'node'.  Within
each element is another list, where the names correspond to attributes
and the values correspond to the value to use globally on that
attribute.  An example of this structure can be seen with the default
list provided by \Rfunction{getDefaultAttrs}:

<<defAttrs>>=
z <- getDefaultAttrs()
z
@

Users can also set attributes per-node and per-edge.  In this case, if
an attribute is defined for a particular node then that node uses the
specified attribute and the rest of the nodes use the global default.
Note that any attribute that is set on a per-node or per-edge basis
\texttt{must} have a default set globally, due to the way that
Graphviz sets attributes.  Both the per-node and per-edge attributes
are set in the same basic manner - the attributes are set using a list
where the names of the elements are the attributes, and each element
contains a named vector.  The names of this vector correspond to
either node names or edge names, and the values of the vector are the
values to set the attribute to for that node or edge.  The one place
to take care about is with the edge names in that the name of an edge
is x~y where x is the 'from' node and y is the 'to' node.  Note that
even with an undirected graph that x~y is not the same thing as y~x as
it depends on how the edge was explicitly defined.  These lists are
then passed in to \Rfunction{plot} as the arguments \Robject{nodeAttrs}
and \Robject{edgeAttrs}.  The following sections will demonstrate how to
set per-node and per-edge attributes for commonly desired tasks.  For
these we will construct two lists, \Robject{nAttrs} and \Robject{eAttrs}
to pass in to \Rfunction{plot}.

<<baseLists>>=
nAttrs <- list()
eAttrs <- list()
@

\section{Labels}

By default, nodes use the node name as their label and edges do not
have a label.  However, both can have custom labels supplied via
attributes.

<<labels, fig=TRUE>>=
nAttrs$label <- c(a="lab1", b="lab2", g="lab3")
nAttrs

eAttrs$label <- c("a~h"="test", "h~c"="test2")
eAttrs

plot(g1, nodeAttrs=nAttrs, edgeAttrs=eAttrs)
@

\section{Adding Some Color}

There are many areas where color can be specified to the plotted
graph.  Edges can be drawn in a non-default color, as can nodes.
Nodes can also have a specific \Robject{fillcolor} defined, detailing
what color the interior of the node should be.  The color used for the
labels can also be specified with the \Robject{fontcolor} attribute.

<<colors, fig=TRUE>>=
## Specify node drawing color
nAttrs$color <- c(a="red", b="red", g="green", d="blue")

## Specify edge drawing color
eAttrs$color <- c("a~d"="blue", "h~c"="purple")

## Specify node fill color
nAttrs$fillcolor <- c(j="yellow")

## label color
nAttrs$fontcolor <- c(e="green", f="red")
eAttrs$fontcolor <- c("a~h"="green", "h~c"="brown")

nAttrs
eAttrs

plot(g1, nodeAttrs=nAttrs, edgeAttrs=eAttrs)
@

\section{Setting attributes via node and edge lists}

The user can take a different direction in setting up attributes and
laying out the graph then the one presented above.  The following
method can be used to replicate exactly the same sorts of behaviour
described above, but can be more flexible in some other cases. The functions
\Rfunction{buildNodeList} and \Rfunction{buildEdgeList} will generate
a list of \Robject{pNode} and \Robject{pEdge} objects respectively.
These are used to provide the information for the actual Graphviz
layout (and by default are generated automatically).  By generating
these manually before the layout, one can edit these objects and
perform the layout with these edited lists.

For example:

<<getLists>>=
nodes <- buildNodeList(g1)
edges <- buildEdgeList(g1)
nodes[[1]]
edges[[1]]
@

You can now see the contents of the first \Robject{pNode} and first
\Robject{pEdge} objects in their respective lists.  Now, to
demonstrate some simple attribute examples such as node and edge
color, perhaps we'd like to have the "c" node be blue and the between
"a" and "b" to be colored green, we can set it up as such:

<<colorLists>>=
nodes$"c"@attrs$fillcolor <- "blue"
nodes$"c"
edges$"a~b"@attrs$color <- "green"
edges$"a~b"
@

You can see that the \Robject{attrs} slot now has a 'color' element to
it.  

<<plotListGraph1, fig=TRUE>>=
  vv <- agopen(name="test1", nodes=nodes, edges=edges,
               edgeMode="undirected")
  plot(vv)
@

Note that the name argument is required by Graphviz but is not
currently used for anything in \Rpackage{Rgraphviz}.  The edgeMode
argument is required in this case because Graphviz needs to know if
this graph is directed or not and \Rpackage{Rgraphviz} can't
necessarily determine the status of the graph from the node and edge
lists.  One could suggest to look at the arrowhead/tails (or lack
thereof) and derive it that way, but the arrowhead/tails are
completely independent from the edgemode of the graph:

<<addArrows, fig=TRUE>>=
edges$"a~e"@attrs$arrowhead <- "open"
edges$"a~h"@attrs$arrowhead <- "open"
edges$"a~h"@attrs$arrowtail <- "open"
vv <- agopen(name="test1", nodes=nodes, edges=edges,
               edgeMode="undirected")
plot(vv) 
@

Here we've added our own arrowheads to the a~e and a~h edges as well
as added an arrowtail to the graph - while visually indicating
direction, these will have no bearing on the layout itself as Graphviz
will view these edges as undirected.  This same technique can be used
in the case where a directed graph has reciprocated edges and one
wants to combine those edges into single edges with arrows in both
directions.

\section{Plotting with non-standard nodes}

The \Rpackage{Rgraphviz} package provides for non-standard node drawing.  Note
that these nodes are shaped the same as standard nodes, but are able
to provide for richer information in the actual display.

To do this, lay out the graph using the shape desired - then, when
plotting the laid out graph, one can use the \Robject{drawNode}
argument to \Rfunction{plot} to define how the nodes are drawn.  This
argument can be either of length one (in which case all nodes are
drawn with it) or a list of length equal to the number of nodes in the
graph (in which case the first element of the list is used to draw the
first node, etc).  To work correctly, the function will take two
arguments - the first \Robject{node} is an object of class
\Robject{AgNode}, which describes the node's location and other
information and the second parameter, \Robject{ur} is of class
\Robject{XYPoint} and describes the upper right hand point of the
bounding box (where the lower left is 0,0).  The default function for
node drawing on all nodes is \Rfunction{drawAgNode}, so if one wants
to use a custom function for some nodes but the standard function for
others, the list passed in to \Robject{drawNode} can have the custom
functions in the elements corresponding to those nodes desired to have
special display and \Rfunction{drawAgNode} in the elements
corresponding to the nodes where standard display is desired.

One function included with the \Rpackage{Rgraphviz} package that can
be used for such alternate node drawing is \Rfunction{pieGlyph}.  This
allows users to put arbitrary pie charts in as circular nodes.  As an
example, we will take the \Robject{eset} dataset from the
\Rpackage{Biobase} package and will create a graph where each node
corresponds to one of a set of Affymetrix probes represented in that
exprSet and draw each node with a pie chart representing the
expression levels of the samples in the exprSet for that probe.

<<pieChart, fig=TRUE>>=

require("Biobase") || stop("Biobase needed for this example")
data(eset)

exprs <- exprs(eset)[100:109,]
probes <- rownames(exprs)

## Construct a graph for these nodes
set.seed(123)
pieGraph <- randomGraph(probes, 1:4, .2)

## Do a layout of the graph, but don't plot it yet
pgLayout <- agopen(pieGraph, "foo")

counts <-  apply(exprs, 1, function(x) {
              table(cut(x, breaks=c(-Inf, 100, 500, Inf)))
           })

## Need to construct a list of drawing functions for the Rgraphviz plot
plotPieChart <- function(curPlot, counts) {
    buildDrawing <- function(x) {
	force(x)
	y <- x*100+1
	function(node, ur) {
            nodeCenter <- getNodeCenter(node)
            pieGlyph(y, xpos=getX(nodeCenter),
                     ypos=getY(nodeCenter),
                     radius=getNodeRW(node),
                     col=c("blue", "green", "red"))
	}
    }
    drawing <- vector(mode="list", length=length(probes))
    for (i in 1:length(drawing)) {
	drawing[[i]] <- buildDrawing(counts[,i])
    }

    plot(curPlot, drawNode=drawing, main="Example Pie Chart Plot")
    legend(0, 65, legend=c("No Data", "0-100", "101-500", "500+"),
           fill=c("white", "blue", "green", "red"))
}
plotPieChart(pgLayout, counts)
@

To perform this plot, we constructed a complete function, although
this is not necessary - one can take any path they desire to build the
list of drawing functions.  Also note that in this plot the nodes do
not have labels as it would look confusing, but those could be easily
added with a line such as \Robject{drawTxtLabel(txtLabel(node),
getX(nodeCenter), getY(nodeCenter))} in the \Rfunction{buildDrawing}
sub-function above.  The \Rfunction{drawAgNode} should be used as a
guide for basic activities such as this.

\section{Example Graphs}

Here are some other examples of graphs that can be drawn:

Unix history, using "dot" and "neato" layouts ...

<<unixHistory,fig=TRUE>>=
z <- new("graphNEL", nodes=c("5th Edition","6th Edition","Interdata",
"7th Edition", "V7M", "8th Edition", "1 BSD", "2 BSD", "2.8 BSD",
"32V", "3 BSD", "4 BSD", "4.1 BSD", "4.2 BSD", "PWB 1.0", "USG 1.0",
"CB Unix 1", "CB Unix 2", "CB Unix 3", "USG 2.0", "USG 3.0",
"PWB 2.0", "Unix/TS 1.0", "Unix/TS 3.0", "Unix/TS++",
"TS 4.0", "System V.0", "System V.2", "LSX", "Mini Unix",
"Wollongong", "Ultrix-11", "Xenix", "UniPlus+", "9th Edition",
"2.9 BSD", "Ultrix-32", "PDP-11 Sys V", "System V.3","4.3 BSD",
"PWB 1.2"), edgeL=list(
"5th Edition"=list(edges=c(2,15)),
"6th Edition"=list(edges=c(29,7,30,31,3)),
"Interdata"=list(edges=c(24,22,4)),
"7th Edition"=list(edges=c(6,10,5,32,33,34)), "V7M"=list(edges=32),
"8th Edition"=list(edges=35), "1 BSD"=list(edges=8),
"2 BSD"=list(edges=9), "2.8 BSD"=list(edges=c(32,36)),
"32V"=list(edges=11), "3 BSD"=list(edges=12), "4 BSD"=list(edges=13),
"4.1 BSD"=list(edges=c(14,9,6)), "4.2 BSD"=list(edges=c(40,37)),
"PWB 1.0"=list(edges=c(41, 16)), "PWB 1.2"=list(edges=22),
"USG 1.0"=list(edges=c(17, 20)), "CB Unix 1"=list(edges=18),
"CB Unix 2"=list(edges=19), "CB Unix 3"=list(edges=c(25,38)),
"USG 2.0"=list(edges=21), "USG 3.0"=list(edges=24),
"PWB 2.0"=list(edges=24), "Unix/TS 1.0"=list(edges=24),
"Unix/TS 3.0"=list(edges=26), "Unix/TS++"=list(edges=26),
"TS 4.0"=list(edges=27),
"System V.0"=list(edges=28), "System V.2"=list(edges=39),
LSX=character(),  "Mini Unix"=character(), "Wollongong"=character(),
"Ultrix-11"=character(), "Xenix"=character(), "UniPlus+"=character(),
"9th Edition"=character(), "2.9 BSD"=character(),
"Ultrix-32"=character(), "PDP-11 Sys V"=character(),
"System V.3"=character(), "4.3 BSD"=character()),
edgemode="directed")
a <- plot(z)
a <- plot(z,"neato")
@

OS process map, using "twopi" layout and setting the \Robject{root}
attribute to change the center node of the "twopi" layout:
<<OSneato, fig=TRUE>>=
z <- new("graphNEL",
nodes=c("run","intr","runbl","kernel","zombie","sleep","runmem","swap","runswap","new"),
edgeL=list("run"=list(edges=c(2,3,4)),"intr"=list(edges=c(1,3)),
"runbl"=list(edges=c(1,2)), "kernel"=list(edges=c(1,5,6,7)),
"zombie"=list(edges=4),
"sleep"=list(edges=c(4,7,8)), "runmem"=list(edges=c(4,6,9,10)),
"swap"=list(edges=c(6,9)),
"runswap"=list(edges=c(7,8,10)), "new"=list(edges=c(7,9))))

curAttrs <- getDefaultAttrs("twopi")
curAttrs$graph$root <- "runmem"
a <- plot(z, "twopi", attrs=curAttrs)
@

\end{document}
